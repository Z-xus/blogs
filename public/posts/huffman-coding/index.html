<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Huffman Coding | Zxus Blogs</title><meta name=keywords content><meta name=description content="Huffman Coding
Huffman Coding is a popular algorithm used for data compression. It was developed by David A. Huffman in 1952 as part of his research on finding the most efficient binary code. Huffman Coding is widely used because of its simplicity and effectiveness in reducing data size without losing information.
Table of Contents

Introduction
How Huffman Coding Works
Example of Huffman Coding
Decoding with Huffman Code
Advantages of Huffman Coding
Applications of Huffman Coding
Limitations of Huffman Coding


Introduction
Huffman Coding is a lossless compression algorithm, meaning no data is lost during the compression process. The algorithm is based on the concept of variable-length encoding, where more frequent characters are assigned shorter codes, and less frequent characters receive longer codes. This way, Huffman Coding minimizes the total number of bits needed to represent a data set, leading to efficient compression."><meta name=author content="Zxus"><link rel=canonical href=http://localhost:1313/posts/huffman-coding/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/huffman-coding/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/huffman-coding/"><meta property="og:site_name" content="Zxus Blogs"><meta property="og:title" content="Huffman Coding"><meta property="og:description" content="Huffman Coding Huffman Coding is a popular algorithm used for data compression. It was developed by David A. Huffman in 1952 as part of his research on finding the most efficient binary code. Huffman Coding is widely used because of its simplicity and effectiveness in reducing data size without losing information.
Table of Contents Introduction How Huffman Coding Works Example of Huffman Coding Decoding with Huffman Code Advantages of Huffman Coding Applications of Huffman Coding Limitations of Huffman Coding Introduction Huffman Coding is a lossless compression algorithm, meaning no data is lost during the compression process. The algorithm is based on the concept of variable-length encoding, where more frequent characters are assigned shorter codes, and less frequent characters receive longer codes. This way, Huffman Coding minimizes the total number of bits needed to represent a data set, leading to efficient compression."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-04T17:32:51+05:30"><meta property="article:modified_time" content="2024-11-04T17:32:51+05:30"><meta property="og:image" content="http://localhost:1313/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/logo.png"><meta name=twitter:title content="Huffman Coding"><meta name=twitter:description content="Huffman Coding
Huffman Coding is a popular algorithm used for data compression. It was developed by David A. Huffman in 1952 as part of his research on finding the most efficient binary code. Huffman Coding is widely used because of its simplicity and effectiveness in reducing data size without losing information.
Table of Contents

Introduction
How Huffman Coding Works
Example of Huffman Coding
Decoding with Huffman Code
Advantages of Huffman Coding
Applications of Huffman Coding
Limitations of Huffman Coding


Introduction
Huffman Coding is a lossless compression algorithm, meaning no data is lost during the compression process. The algorithm is based on the concept of variable-length encoding, where more frequent characters are assigned shorter codes, and less frequent characters receive longer codes. This way, Huffman Coding minimizes the total number of bits needed to represent a data set, leading to efficient compression."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Huffman Coding","item":"http://localhost:1313/posts/huffman-coding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Huffman Coding","name":"Huffman Coding","description":"Huffman Coding Huffman Coding is a popular algorithm used for data compression. It was developed by David A. Huffman in 1952 as part of his research on finding the most efficient binary code. Huffman Coding is widely used because of its simplicity and effectiveness in reducing data size without losing information.\nTable of Contents Introduction How Huffman Coding Works Example of Huffman Coding Decoding with Huffman Code Advantages of Huffman Coding Applications of Huffman Coding Limitations of Huffman Coding Introduction Huffman Coding is a lossless compression algorithm, meaning no data is lost during the compression process. The algorithm is based on the concept of variable-length encoding, where more frequent characters are assigned shorter codes, and less frequent characters receive longer codes. This way, Huffman Coding minimizes the total number of bits needed to represent a data set, leading to efficient compression.\n","keywords":[],"articleBody":"Huffman Coding Huffman Coding is a popular algorithm used for data compression. It was developed by David A. Huffman in 1952 as part of his research on finding the most efficient binary code. Huffman Coding is widely used because of its simplicity and effectiveness in reducing data size without losing information.\nTable of Contents Introduction How Huffman Coding Works Example of Huffman Coding Decoding with Huffman Code Advantages of Huffman Coding Applications of Huffman Coding Limitations of Huffman Coding Introduction Huffman Coding is a lossless compression algorithm, meaning no data is lost during the compression process. The algorithm is based on the concept of variable-length encoding, where more frequent characters are assigned shorter codes, and less frequent characters receive longer codes. This way, Huffman Coding minimizes the total number of bits needed to represent a data set, leading to efficient compression.\nHow Huffman Coding Works Step-by-Step Process Frequency Calculation:\nCount the frequency of each character in the data. Create Leaf Nodes:\nFor each character, create a leaf node containing its frequency and value. Build a Priority Queue:\nInsert all leaf nodes into a priority queue (or min-heap), sorted by frequency (smallest frequency at the top). Construct the Huffman Tree:\nRepeat the following until only one node remains in the priority queue: Extract the two nodes with the lowest frequency. Create a new node with a frequency equal to the sum of these two nodes. Set the two extracted nodes as the left and right children of the new node. Insert the new node back into the priority queue. The last remaining node is the root of the Huffman Tree. Assign Codes:\nTraverse the Huffman Tree from the root to each leaf node. Assign a binary 0 for each left edge and 1 for each right edge. The path to each character forms its Huffman Code. Example of Huffman Coding Consider the following example data:\nCharacter Frequency A 5 B 9 C 12 D 13 E 16 F 45 Step 1: Build the Huffman Tree Start with individual nodes sorted by frequency. Merge nodes with the lowest frequencies until only one node remains. The process would look like this:\nCombine A (5) and B (9) → New Node (14) Combine C (12) and D (13) → New Node (25) Combine New Node (14) and E (16) → New Node (30) Combine New Node (25) and F (45) → New Node (70) Combine New Node (30) and New Node (70) → Final Root (100) Step 2: Assign Codes After constructing the Huffman Tree, assign binary codes based on the path to each character:\nCharacter Huffman Code A 1100 B 1101 C 100 D 101 E 111 F 0 Result: The character with the highest frequency (F) has the shortest code (0), and characters with lower frequencies have longer codes.\nEncoding Example If we encode the string ABCD, it would be:\nA → 1100 B → 1101 C → 100 D → 101 Encoded string: 11001101100101\nDecoding with Huffman Code Decoding is performed by traversing the Huffman Tree:\nStart at the root. For each 0, move left; for each 1, move right. When a leaf node is reached, add the character to the output. Return to the root and repeat until the entire encoded string is decoded. Advantages of Huffman Coding Lossless Compression: No data is lost during compression. Efficiency: Saves space by assigning shorter codes to more frequent characters. Optimal for Given Frequencies: Huffman Coding guarantees the minimum number of bits required for a set of characters based on their frequencies. Limitations of Huffman Coding Fixed Frequencies: Huffman Coding is optimal for a fixed set of frequencies. Changes in frequency distribution may lead to inefficiency. Not Suitable for Real-Time Applications: For large and variable data, the tree-building process can be slow. Suboptimal for Small Files: May add overhead for very small files where the additional tree data outweighs compression benefits. Applications of Huffman Coding Data Compression:\nWidely used in file compression formats like ZIP and RAR. Multimedia Compression:\nUtilized in JPEG and MP3 formats to reduce file size. Text Compression:\nUseful in compressing text files and emails for faster transmission. Telecommunication:\nEmployed in transmission protocols to optimize data transfer efficiency. Data Transmission:\nApplied in network data packet optimization for reducing bandwidth usage. Summary Huffman Coding is a fundamental algorithm for lossless data compression, leveraging variable-length encoding to minimize storage and bandwidth requirements. By prioritizing more frequent characters with shorter codes, it efficiently reduces data size. Its applications span various fields, including file compression, multimedia, and network optimization, making it a cornerstone of efficient data handling in digital systems.\n","wordCount":"766","inLanguage":"en","image":"http://localhost:1313/logo.png","datePublished":"2024-11-04T17:32:51+05:30","dateModified":"2024-11-04T17:32:51+05:30","author":{"@type":"Person","name":"Zxus"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/huffman-coding/"},"publisher":{"@type":"Organization","name":"Zxus Blogs","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Zxus (Alt + H)"><img src=http://localhost:1313/%F0%9F%9A%80 alt aria-label=logo height=35>Zxus</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/posts/ title=Articles><span>Articles</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/search/ title=Search><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Huffman Coding</h1><div class=post-meta><span title='2024-11-04 17:32:51 +0530 IST'>November 4, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;766 words&nbsp;·&nbsp;Zxus&nbsp;|&nbsp;<a href=https://github.com/Z-xus/blogs/tree/main/content/posts/huffman-coding.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#table-of-contents>Table of Contents</a></li><li><a href=#introduction>Introduction</a></li><li><a href=#how-huffman-coding-works>How Huffman Coding Works</a><ul><li><a href=#step-by-step-process>Step-by-Step Process</a></li></ul></li><li><a href=#example-of-huffman-coding>Example of Huffman Coding</a><ul><li><a href=#step-1-build-the-huffman-tree>Step 1: Build the Huffman Tree</a></li><li><a href=#step-2-assign-codes>Step 2: Assign Codes</a></li><li><a href=#encoding-example>Encoding Example</a></li></ul></li><li><a href=#decoding-with-huffman-code>Decoding with Huffman Code</a></li><li><a href=#advantages-of-huffman-coding>Advantages of Huffman Coding</a></li><li><a href=#limitations-of-huffman-coding>Limitations of Huffman Coding</a></li><li><a href=#applications-of-huffman-coding>Applications of Huffman Coding</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></details></div><div class=post-content><h1 id=huffman-coding>Huffman Coding<a hidden class=anchor aria-hidden=true href=#huffman-coding>#</a></h1><p><strong>Huffman Coding</strong> is a popular algorithm used for data compression. It was developed by <strong>David A. Huffman</strong> in 1952 as part of his research on finding the most efficient binary code. Huffman Coding is widely used because of its simplicity and effectiveness in reducing data size without losing information.</p><h2 id=table-of-contents>Table of Contents<a hidden class=anchor aria-hidden=true href=#table-of-contents>#</a></h2><ul><li><a href=#introduction>Introduction</a></li><li><a href=#how-huffman-coding-works>How Huffman Coding Works</a></li><li><a href=#example-of-huffman-coding>Example of Huffman Coding</a></li><li><a href=#decoding-with-huffman-code>Decoding with Huffman Code</a></li><li><a href=#advantages-of-huffman-coding>Advantages of Huffman Coding</a></li><li><a href=#applications-of-huffman-coding>Applications of Huffman Coding</a></li><li><a href=#limitations-of-huffman-coding>Limitations of Huffman Coding</a></li></ul><hr><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Huffman Coding is a <strong>lossless compression algorithm</strong>, meaning no data is lost during the compression process. The algorithm is based on the concept of variable-length encoding, where more frequent characters are assigned shorter codes, and less frequent characters receive longer codes. This way, Huffman Coding minimizes the total number of bits needed to represent a data set, leading to efficient compression.</p><hr><h2 id=how-huffman-coding-works>How Huffman Coding Works<a hidden class=anchor aria-hidden=true href=#how-huffman-coding-works>#</a></h2><h3 id=step-by-step-process>Step-by-Step Process<a hidden class=anchor aria-hidden=true href=#step-by-step-process>#</a></h3><ol><li><p><strong>Frequency Calculation</strong>:</p><ul><li>Count the frequency of each character in the data.</li></ul></li><li><p><strong>Create Leaf Nodes</strong>:</p><ul><li>For each character, create a leaf node containing its frequency and value.</li></ul></li><li><p><strong>Build a Priority Queue</strong>:</p><ul><li>Insert all leaf nodes into a <strong>priority queue</strong> (or min-heap), sorted by frequency (smallest frequency at the top).</li></ul></li><li><p><strong>Construct the Huffman Tree</strong>:</p><ul><li>Repeat the following until only one node remains in the priority queue:<ol><li>Extract the two nodes with the lowest frequency.</li><li>Create a new node with a frequency equal to the sum of these two nodes.</li><li>Set the two extracted nodes as the left and right children of the new node.</li><li>Insert the new node back into the priority queue.</li></ol></li><li>The last remaining node is the <strong>root of the Huffman Tree</strong>.</li></ul></li><li><p><strong>Assign Codes</strong>:</p><ul><li>Traverse the Huffman Tree from the root to each leaf node.</li><li>Assign a binary <code>0</code> for each left edge and <code>1</code> for each right edge.</li><li>The path to each character forms its <strong>Huffman Code</strong>.</li></ul></li></ol><hr><h2 id=example-of-huffman-coding>Example of Huffman Coding<a hidden class=anchor aria-hidden=true href=#example-of-huffman-coding>#</a></h2><p>Consider the following example data:</p><table><thead><tr><th>Character</th><th>Frequency</th></tr></thead><tbody><tr><td>A</td><td>5</td></tr><tr><td>B</td><td>9</td></tr><tr><td>C</td><td>12</td></tr><tr><td>D</td><td>13</td></tr><tr><td>E</td><td>16</td></tr><tr><td>F</td><td>45</td></tr></tbody></table><h3 id=step-1-build-the-huffman-tree>Step 1: Build the Huffman Tree<a hidden class=anchor aria-hidden=true href=#step-1-build-the-huffman-tree>#</a></h3><ol><li>Start with individual nodes sorted by frequency.</li><li>Merge nodes with the lowest frequencies until only one node remains.</li></ol><p>The process would look like this:</p><ul><li>Combine A (5) and B (9) → New Node (14)</li><li>Combine C (12) and D (13) → New Node (25)</li><li>Combine New Node (14) and E (16) → New Node (30)</li><li>Combine New Node (25) and F (45) → New Node (70)</li><li>Combine New Node (30) and New Node (70) → Final Root (100)</li></ul><h3 id=step-2-assign-codes>Step 2: Assign Codes<a hidden class=anchor aria-hidden=true href=#step-2-assign-codes>#</a></h3><p>After constructing the Huffman Tree, assign binary codes based on the path to each character:</p><table><thead><tr><th>Character</th><th>Huffman Code</th></tr></thead><tbody><tr><td>A</td><td>1100</td></tr><tr><td>B</td><td>1101</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>101</td></tr><tr><td>E</td><td>111</td></tr><tr><td>F</td><td>0</td></tr></tbody></table><p><strong>Result</strong>: The character with the highest frequency (<code>F</code>) has the shortest code (<code>0</code>), and characters with lower frequencies have longer codes.</p><h3 id=encoding-example>Encoding Example<a hidden class=anchor aria-hidden=true href=#encoding-example>#</a></h3><p>If we encode the string <code>ABCD</code>, it would be:</p><ul><li><code>A</code> → 1100</li><li><code>B</code> → 1101</li><li><code>C</code> → 100</li><li><code>D</code> → 101</li></ul><p>Encoded string: <strong><code>11001101100101</code></strong></p><hr><h2 id=decoding-with-huffman-code>Decoding with Huffman Code<a hidden class=anchor aria-hidden=true href=#decoding-with-huffman-code>#</a></h2><p>Decoding is performed by traversing the Huffman Tree:</p><ol><li>Start at the root.</li><li>For each <code>0</code>, move left; for each <code>1</code>, move right.</li><li>When a leaf node is reached, add the character to the output.</li><li>Return to the root and repeat until the entire encoded string is decoded.</li></ol><hr><h2 id=advantages-of-huffman-coding>Advantages of Huffman Coding<a hidden class=anchor aria-hidden=true href=#advantages-of-huffman-coding>#</a></h2><ul><li><strong>Lossless Compression</strong>: No data is lost during compression.</li><li><strong>Efficiency</strong>: Saves space by assigning shorter codes to more frequent characters.</li><li><strong>Optimal for Given Frequencies</strong>: Huffman Coding guarantees the minimum number of bits required for a set of characters based on their frequencies.</li></ul><hr><h2 id=limitations-of-huffman-coding>Limitations of Huffman Coding<a hidden class=anchor aria-hidden=true href=#limitations-of-huffman-coding>#</a></h2><ul><li><strong>Fixed Frequencies</strong>: Huffman Coding is optimal for a fixed set of frequencies. Changes in frequency distribution may lead to inefficiency.</li><li><strong>Not Suitable for Real-Time Applications</strong>: For large and variable data, the tree-building process can be slow.</li><li><strong>Suboptimal for Small Files</strong>: May add overhead for very small files where the additional tree data outweighs compression benefits.</li></ul><hr><h2 id=applications-of-huffman-coding>Applications of Huffman Coding<a hidden class=anchor aria-hidden=true href=#applications-of-huffman-coding>#</a></h2><ol><li><p><strong>Data Compression</strong>:</p><ul><li>Widely used in <strong>file compression formats</strong> like ZIP and RAR.</li></ul></li><li><p><strong>Multimedia Compression</strong>:</p><ul><li>Utilized in <strong>JPEG</strong> and <strong>MP3</strong> formats to reduce file size.</li></ul></li><li><p><strong>Text Compression</strong>:</p><ul><li>Useful in compressing text files and emails for faster transmission.</li></ul></li><li><p><strong>Telecommunication</strong>:</p><ul><li>Employed in transmission protocols to optimize data transfer efficiency.</li></ul></li><li><p><strong>Data Transmission</strong>:</p><ul><li>Applied in network data packet optimization for reducing bandwidth usage.</li></ul></li></ol><hr><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Huffman Coding is a fundamental algorithm for lossless data compression, leveraging variable-length encoding to minimize storage and bandwidth requirements. By prioritizing more frequent characters with shorter codes, it efficiently reduces data size. Its applications span various fields, including file compression, multimedia, and network optimization, making it a cornerstone of efficient data handling in digital systems.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/fin-for-noobs/><span class=title>« Prev</span><br><span>Finance for Noobs</span>
</a><a class=next href=http://localhost:1313/posts/git-submodules/><span class=title>Next »</span><br><span>Git Submodules</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Zxus Blogs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>